% This script makes plots using the bootstrapping data generated by main.m
% First it find the 95 percentile of the shuffled data and then shows the
% original data compared to the 95 percentile. Anything above the 95th
% percentile we can say is above what we could expect by chance 95% of the
% time. Finally, marks are made to indicate when the antennae are moved
% back and forth. This version (3) is different from the originial because
% it separates the whole train into trials. Then, instead of jittering
% individual spikes, it just switches around between trials. For example,
% the train for neuron 1 from trial 1 will be matched with the train for
% neuron 2 from trial 17.

% uncomment this to add my toolbox directory to the matlab path. only need
% to do this when running on the cluster:
addpath(genpath('/home/mes41/toolbox/'))

debugdisp('Hello World!')

close all
clear all

%%%% Parameters (SET THESE!!) %%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

filename = 'cockroach6-19-2008.mat';
dt = 1e-3; % time resolution of spike trains in seconds
n_neurons = 10; %number of neurons


% This is the column that contains trial start times.
col_trial = 12;
% 11 for sim_left or 13 for sim_in

significance_level = 0.01;
% used to determine what is significant after bootstrapping

% cps parameters
triangleWidth = (0.005)*2 + 1;
binSize = 0.1;
binShift = 0.005;
stepSize = dt;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% End of Parameters %%%%%%%%

triangleSteps = triangleWidth / stepSize;
binSteps = floor(binSize / stepSize);
shiftSteps = floor(binShift / stepSize);

%% Load data
% load in cockroach data
load(filename)

%% Separate data into trials

t_start = data(:,col_trial); %start times of trials (seconds)
t_start = t_start(~isnan(t_start)) - 1; %remove NaN's

T_trial = 5; %min(diff(t_start)); %length of one trial (seconds)

nChunks = floor(T_trial/binSize);
chunkSteps = binSize/dt;

% % shorten T_trial if necessary to make sure that it is evenly divisible
% % into windows
% T_trial = floor(T_trial/dtw) * dtw;


t_end = t_start + T_trial; %ending times of trials (seconds)



%% Make spike trains

debugdisp('Data loaded, now making spike trains.')

n_trials = length(t_start);

% trial x time x neuron
spikes = zeros(n_trials, ceil(T_trial/dt), n_neurons);
for neuron = 1:n_neurons
    debugdisp(['Neuron ' int2str(neuron)])
    allSpikeTimes  = data(:,neuron); % get all spike times for this neuron

    for trial = 1:n_trials

        %         debugdisp(['-->Trial ' int2str(trial)])

        % only get spike times that are in this trial
        spikeTimes = allSpikeTimes( ...
            allSpikeTimes >= t_start(trial) & ...
            allSpikeTimes <  t_end(trial));

        % align spikes so beginning of trial is at t=0
        spikeTimes = spikeTimes - t_start(trial);

        % timesteps where there will be spikes
        t = ceil(spikeTimes/dt);

        % insert spikes!
        spikes(trial, t, neuron) = 1;
    end
end

%% make vector of behaviors
%
% behavior = zeros(endStep,1); %initialize empty behavior vector
% for col = 11:14
%     timestamps = data(:,col);
%     ind = round(timestamps / dt); %convert time to index in vector
%     ind = ind( ~isnan(ind) ); %only uses indices that are not nan
%     steps_per_bin = windowSize / dt;
%     behavior(ind) = col; %set behavior vector to col wherever behaviror was recorded
% end

% % reduce behavior to bins
% behavior = max(reshape( ...
%     behavior(1:(length(behavior)-mod(length(behavior),steps_per_bin))), ...
%     steps_per_bin, []));

%% Make index lookup table
% this reduces the size of the variables I will use because I assign each
% pair of neurons a single index. This eliminates duplicating all of my
% information across the diagonal ( the pair n1,n2 has the same index as
% the pair n2,n1).

index_lookup = zeros(n_neurons);
ind = 0;
for n1 = 1:n_neurons
    for n2 = (n1+1):n_neurons
        ind = ind+1;
        index_lookup(n1,n2) = ind;
        index_lookup(n2,n1) = ind;
    end
end



%% Do the bootstrapping
max_ind = max(max(index_lookup)); % number of combinations of neurons
max_iter = n_trials * (n_trials-1); % number of combinations of trials
max_bin = floor( (size(spikes,2)-binSteps) / shiftSteps); % bins for cps

% this will store results of bootstrapping
bootstrapped = zeros( max_iter , max_bin , max_ind );
actual = zeros(n_trials, max_bin, max_ind);

% for all combinations of neurons
for n1 = 1:n_neurons
    for n2 = (n1+1):n_neurons

        debugdisp(['Bootstrapping neurons ' int2str(n1) ' and ' int2str(n2) ])

        % reset iter and ind now that we are on a new pair of neurons
        iter = 0;
        ind = index_lookup(n1,n2);

        % for all trials
        for trial1 = 1:n_trials

            % find actual synchrony in this trial
            spikes_temp1 = squeeze(spikes(trial1, :, n1));
            spikes_temp2 = squeeze(spikes(trial1, :, n2));
            spikes_temp = [spikes_temp1; spikes_temp2]';
            temp = cps_sw( spikes_temp, triangleWidth, binSize, binShift, stepSize );
            actual(trial1,:,ind) = temp(1,2,:);


            % bootstrap 19 times for each trial
            for trial2 = 1:19

                % pick spike trains for this iteration
                %% Shuffle order of bins

                newSpikes = zeros(size(spikes));
                newOrder = randperm(nChunks);
                for newChunk = 1:nChunks
                    newRows = (1:chunkSteps) + (newChunk-1)*chunkSteps;
                    oldChunk = newOrder(newChunk);
                    oldRows = (1:chunkSteps) + (oldChunk-1)*chunkSteps;

                    newSpikes(newRows,2) = spikes(trial1,oldRows,n2);
                end

                newSpikes(:,1) = spikes(trial1,:,n1);



                % find synchrony
                temp = cps_sw( newSpikes, triangleWidth, binSize, binShift, stepSize );

                iter = iter+1;
                bootstrapped(iter,:,ind) = temp(1,2,:);



            end %trial2
        end %trial1
    end %n2
end %n1

filename = [ 'results_' sprintf('%04d%02d%02d_%02d%02d%02.0f',clock) '.mat'];
save(filename)
debugdisp(['Results saved to ' filename])


debugdisp('Goodbye world!')